# Copilot instructions for BuildPro (app)

These short instructions help AI coding agents make productive, minimally-surprising changes to this repository.

## Big picture

- Monorepo-like single-codebase: a Vite + React frontend (root) and a minimal Node/Express backend in `/server` written in TypeScript.
- Local development defaults to SQLite; in production (Vercel/Supabase) the app switches to PostgreSQL if `DATABASE_URL` is set. See `/server/database.ts` for the adapter logic.
- Key integration points: Gemini APIs (`services/geminiService.ts`) for AI features and Supabase (`services/supabaseClient.ts` + `SUPABASE_SETUP.md`) for auth, storage, and Postgres DB.

## Start / build / debugging

- Install deps: `npm install`
- Start backend (local SQLite): `npm start` (runs `server/index.ts` via `ts-node`)
- Initialize DB explicitly: `npm run init-db` (uses `server/init-db.ts`)
- Start frontend: `npm run dev` (Vite)
- Build frontend: `npm run build`
- Type-check across the repo: `npx tsc -p tsconfig.json --noEmit`

There are no automated test scripts in `package.json`; use TypeScript checks and manual run of the server + UI to validate integration changes.

## Important conventions / patterns (project-specific)

- DB adapter supports both SQLite and Postgres. For Postgres the `PostgresAdapter` converts `?` placeholders to `$1,$2...` — prefer using `?` in SQL strings; the adapter will normalize for Postgres. (See `/server/database.ts`)
- Many DB fields store JSON as strings (e.g. `projects.weatherLocation`, `projects.zones`, `tasks.dependencies`, `team.skills`, `dayworks.labor`). Server code serializes/deserializes these (see `server/index.ts` and `server/database.ts`'s schema).
- Generic CRUD routes are generated by `createCrudRoutes(tableName, jsonFields)` in `server/index.ts`. To add a new simple resource, register it there and include field names that should be parsed as JSON.
- Seed data and basic test data live in `/server/seed.ts`. Use the seed step after DB init to get sample data.
- Env var conventions:
  - Gemini AI key: `GEMINI_API_KEY` (also may be available as `API_KEY` in some build configs). Prefer `GEMINI_API_KEY`.
  - Supabase: `VITE_SUPABASE_URL`, `VITE_SUPABASE_ANON_KEY` are used by the frontend. See `SUPABASE_SETUP.md` for DB and storage setup and required policies.
  - Database switching: `DATABASE_URL` (and `PGSSLMODE` for SSL policies) toggles Postgres mode.
- When modifying DB schema, update `server/database.ts`'s `initSchema()` migrations or add a clear migration path—there is no external migration tool.

## External APIs & caching

- Gemini usage lives in `services/geminiService.ts`; prefer passing a `systemInstruction` and limit large inline binary data unless necessary. The service contains helper functions for streaming, image and video generation.
- Supabase file uploads use `services/supabaseClient.ts::uploadFile` and expect a `documents` bucket by default.

## Quick pointers for PRs and code changes

- Small API changes: Update `createCrudRoutes` registration if adding a new entity and list JSON fields that need parsing.
- Large DB changes: add migration logic to `initSchema()` in `server/database.ts`; ensure seed data in `server/seed.ts` still applies.
- Environment flags: verify `GEMINI_API_KEY` (AI features) and `VITE_SUPABASE_*` vars for CI/deploy environments.
- Prefer using the `apiKey` variable for outgoing requests to Gemini (do not scatter direct references to `process.env.API_KEY` in code).
- Verify runtime behavior manually after schema changes: start server (`npm start`) and exercise frontend CRUD flows.

## Files of interest (examples)

- `server/index.ts` — server routes and `createCrudRoutes` pattern.
- `server/database.ts` — DB adapter and schema init/migrations.
- `server/seed.ts` — seed/sample data.
- `services/geminiService.ts` — AI interactions and helpers.
- `services/supabaseClient.ts` — Supabase storage + client usage.
- `SUPABASE_SETUP.md` — steps to connect Supabase (buckets, policies, `DATABASE_URL`) and Vercel env vars.

---

If anything above is unclear or missing (e.g., additional environment variables, missing runtime steps, or patterns not captured), tell me which area to expand and I’ll update this file. 
